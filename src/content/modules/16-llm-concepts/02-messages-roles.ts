import type { Lesson } from '@/types'

export const lesson: Lesson = {
  id: '02-messages-roles',
  slug: 'messages-roles',
  title: 'Messages & Roles',
  description: 'Learn about System, User, and Assistant roles and how to structure a conversation with an LLM.',
  order: 2,
  estimatedMinutes: 8,
  difficulty: 'beginner',
  xpReward: 50,
  prerequisites: ['01-what-are-llms'],
  tags: ['ai', 'concepts', 'messages'],
  keyConcepts: [
    {
      id: 'system-role',
      term: 'System Message',
      definition: 'Sets the overall behavior, persona, and constraints for the AI assistant.',
      whyItMatters: 'The system message is your primary lever for controlling the "vibes" and strictness of the AI\'s output.',
    },
    {
      id: 'user-role',
      term: 'User Message',
      definition: 'The input provided by the human, containing the specific request or question.',
      whyItMatters: 'The user message is the variable part of the request that changes based on user input.',
    },
    {
      id: 'assistant-role',
      term: 'Assistant Message',
      definition: 'The response generated by the LLM. In multi-turn conversations, you feed previous assistant responses back to the model.',
      whyItMatters: 'Context is built by appending assistant and user messages to the conversation history.',
    },
  ],
  steps: [
    {
      id: 'step-1-anatomy',
      order: 1,
      type: 'instruction',
      title: 'Conversation Structure',
      content: `# Anatomy of a Chat

LLM APIs (like Claude or GPT) don't just take a single string. They take an **array of messages**.`,
      codeExample: {
        code: `const messages = [
  { role: "system", content: "You are a helpful coding tutor." },
  { role: "user", content: "What is TypeScript?" },
];`,
        language: 'typescript',
      },
    },
    {
      id: 'step-2-history',
      order: 2,
      type: 'instruction',
      title: 'Maintaining State',
      content: `# Building History

To maintain a conversation, you must keep track of the messages and send them all back in each subsequent call.`,
      codeExample: {
        code: `const history = [
  { role: "user", content: "Hi!" },
  { role: "assistant", content: "Hello! How can I help?" },
  { role: "user", content: "Teach me Zod." },
];`,
        language: 'typescript',
      },
    },
    {
      id: 'step-3-exercise-1',
      order: 3,
      type: 'code-exercise',
      title: 'Prompt Builder',
      instructions: `1. Create a function named \`buildPrompt\` that takes a \`systemPrompt\` and a \`userRequest\`.
2. Return an array of two messages in the format: \`{ role: string, content: string }\`.
3. The first message should be the \`system\` role with the \`systemPrompt\`.
4. The second message should be the \`user\` role with the \`userRequest\`.`,
      starterCode: `function buildPrompt(systemPrompt: string, userRequest: string) {
  // Return the messages array here
}
`,
      solutionCode: `function buildPrompt(systemPrompt: string, userRequest: string) {
  return [
    { role: "system", content: systemPrompt },
    { role: "user", content: userRequest },
  ];
}`,
      testCases: [
        {
          id: 'test-1',
          description: 'Should return correct structure',
          testCode: `const res = buildPrompt('S', 'U');
if (res[0].role !== 'system') throw new Error('First must be system');
if (res[1].role !== 'user') throw new Error('Second must be user');`,
        },
      ],
      hints: [
        'Return an array `[]`',
        'Each item is an object `{ role: "...", content: "..." }`',
      ],
      aiHintPrompt: 'The user is learning the basic structure of a chat-completion request.',
    },
  ],
}
